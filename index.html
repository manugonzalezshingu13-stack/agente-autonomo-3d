<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Simulación Multimodal - Agente Autónomo</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #interface { position: absolute; top: 10px; left: 10px; z-index: 100; width: 350px; background: rgba(0,20,0,0.9); border: 2px solid #0f0; color: #0f0; padding: 15px; box-shadow: 0 0 15px #0f0; }
        input { width: 100%; background: #000; border: 1px solid #0f0; color: #0f0; padding: 10px; margin: 10px 0; box-sizing: border-box; }
        button { width: 100%; background: #0f0; color: #000; border: none; padding: 10px; cursor: pointer; font-weight: bold; }
        .data-stream { font-size: 11px; height: 120px; overflow-y: auto; border-top: 1px solid #0f0; margin-top: 10px; }
    </style>
</head>
<body>

<div id="interface">
    <strong>SIMULACIÓN: CIRCUITO DE SEÑALES</strong>
    <div id="propiocepcion" style="font-size: 12px; margin-top:5px;">POS: [0.0, 0, 0.0]</div>
    <input type="text" id="humanPrompt" placeholder="Comando del supervisor...">
    <button onclick="enviarCiclo()">ENVIAR SEÑAL SENSORIAL</button>
    <div id="stream" class="data-stream">> Iniciando telemetría...</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

<script>
    // 1. ESCENA Y CONFIGURACIÓN VISUAL
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(5, 10, 7); scene.add(pointLight);

    // 2. MUNDO FÍSICO (Habitación y Objetos)
    const room = new THREE.Mesh(new THREE.BoxGeometry(16, 8, 16), new THREE.MeshStandardMaterial({color: 0x111111, side: THREE.BackSide}));
    scene.add(room);

    const crearObj = (geo, mat, x, y, z, name) => {
        const m = new THREE.Mesh(geo, mat);
        m.position.set(x, y, z); m.name = name;
        scene.add(m); return m;
    };

    // Escenario detectado por los sensores
    crearObj(new THREE.BoxGeometry(4, 1, 2.5), new THREE.MeshStandardMaterial({color: 0x4a2c1d}), 4, 0.5, -3, "mesa");
    crearObj(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({color: 0x333333}), 4, 1, -1, "silla");
    crearObj(new THREE.BoxGeometry(0.5, 6, 4), new THREE.MeshStandardMaterial({color: 0x222222}), -7.5, 3, 0, "estanteria");
    crearObj(new THREE.SphereGeometry(0.2), new THREE.MeshStandardMaterial({color: 0xff0000}), 4, 1.2, -3, "manzana");
    crearObj(new THREE.SphereGeometry(0.3), new THREE.MeshStandardMaterial({color: 0xffff00}), -2, 0.3, 5, "pelota");

    // 3. EL AGENTE (Cilindro Verde)
    const agente = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 1.2), new THREE.MeshStandardMaterial({color: 0x00ff00}));
    agente.position.y = 0.6;
    scene.add(agente);

    camera.position.set(12, 10, 12); 
    controls.update();

    // 4. CIRCUITO DE DATOS (Envío y Recepción)
    async function enviarCiclo() {
        const stream = document.getElementById('stream');
        const promptInput = document.getElementById('humanPrompt');
        const prompt = promptInput.value;
        
        if(!prompt) return;

        // Propiocepción: Recolectar datos actuales para el LLM
        const telemetria = {
            pos_agente: { x: agente.position.x, z: agente.position.z },
            vision_objetos: scene.children.filter(o => o.name).map(o => ({ nombre: o.name, pos: o.position })),
            input_humano: prompt
        };

        stream.innerHTML += `<br>> Señal enviada: "${prompt}"`;
        
        try {
            // CONEXIÓN CON EL CEREBRO (PIPEDREAM)
            const respuesta = await fetch("https://eohbp1o3g5llmpv.m.pipedream.net/", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(telemetria)
            });

            const datos = await respuesta.json();

            // REACCIÓN FÍSICA A LA CAUSALIDAD
            if (datos && datos.destino) {
                stream.innerHTML += `<br>> IA: ${datos.mensaje}`;
                
                // Movimiento fluido hacia las coordenadas recibidas
                gsap.to(agente.position, { 
                    x: datos.destino.x, 
                    z: datos.destino.z, 
                    duration: 2,
                    onComplete: () => {
                        stream.innerHTML += `<br>> Objetivo alcanzado.`;
                    }
                });
            } else {
                stream.innerHTML += `<br>> IA: No entiendo la instrucción o no veo el objeto.`;
            }

        } catch (error) {
            stream.innerHTML += `<br>> ERROR: Fallo en el circuito de señales.`;
            console.error(error);
        }
        
        promptInput.value = ""; // Limpiar entrada
    }

    // Renderizado continuo
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        document.getElementById('propiocepcion').innerText = `POS: [${agente.position.x.toFixed(1)}, 0, ${agente.position.z.toFixed(1)}]`;
    }
    animate();

    // Ajuste de ventana
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
